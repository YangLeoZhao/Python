import pdb
import numpy
import math
import heapq as heap
from collections import deque

#variable declaration
N = 10 			#N: the number of computers connected to the LAN (variable)
A = 5 			#Data packets arrive at the MAC layer following a Poisson process with an average arrival rate of A packets /second (variable)
W = 1000000		#The speed of the LAN (fixed)
L = 1500*8   	#Packet length (fixed)
#P 				#Persistence parameter for P-persistent CSMA protocols
timeFactor = 1000000 #Time scale 
simTime = 1 #in seconds
average = 0
packetperSecond = 0
totalNumberOfPacket = 0
collisionsDetection = 0
collisionCount = 0

lastPacketTime = 0
currentPacket = 0
lastSender = 0
currentSender = 0


# Presistency = {}
LANUsers = {}
packetHeap = []
collisionList = []


def poissonDistribution():
	packetperSecond = float (numpy.random.poisson(A))
	if (packetperSecond == 0):
		return 0
	else:
		return 1/packetperSecond*timeFactor

class users:
	def __init__(self, userID, lastPacket= 0):
		self.userID = userID
		self.queue = deque ()
		self.lastPacket = lastPacket
		self.backoffCounter = 0
		self.mediumCountdown = 96/W*timeFactor

class packet:
	def __init__ (self, packetTime, user):
		self.packetTime = packetTime
		self.user = user
	def __lt__ (self, other):
		return self.packetTime < other.packetTime
	def __repr__(self):
		return str(self.packetTime) + " " + str(self.user)

#Resolving collisions
def resolveCollision (collisions):
	pdb.set_trace()
	#currentSender

	


#Initializing the users
for x in range (0, 5):
	LANUsers[x] = users (x)

#Calculating when the packets from upper layers will arrive
maxPacketPerUser = 0
condition = len(LANUsers)
for x in range (0, len(LANUsers)):
	condition = len(LANUsers)
	while LANUsers[x].lastPacket < (simTime * timeFactor):
		timeBuffer = poissonDistribution()
		LANUsers[x].lastPacket += timeBuffer
		if (LANUsers[x].lastPacket < (simTime * timeFactor)):
			insertPacket = packet (LANUsers[x].lastPacket, x)
			heap.heappush(packetHeap, insertPacket)
			totalNumberOfPacket +=1
			#print insertPacket.packetTime, insertPacket.user


#print str(packetHeap)

# Calculating possible collisions
while (totalNumberOfPacket > 0):
	currentPacket = heap.heappop(packetHeap)
	totalNumberOfPacket -= 1
	if ((currentPacket.packetTime - lastPacketTime) <= (L*timeFactor/W+ 96*timeFactor/W + abs(currentSender - lastSender)*10/(2*pow(10,8)))):
		if(collisionCount == 0):
			previousPacket = packet (lastPacketTime, lastSender)
			collisionList.append(previousPacket)
		collisionList.append(currentPacket)
		print (str(currentPacket.packetTime) + " " + str(lastPacketTime))
		collisionCount += 1
		collisionsDetection = 1
	elif (((currentPacket.packetTime - lastPacketTime) > (L*timeFactor/W+ 96*timeFactor/W + abs(currentSender - lastSender)*10/(2*pow(10,8)))) and collisionsDetection == 1):
		resolveCollision(collisionList)
		collisionCount = 0
		collisionsDetection = 0
	lastPacketTime = currentPacket.packetTime
	lastSender = currentPacket.user











